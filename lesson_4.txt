//////////////////////////////////////////////////////////////////////////////
//   ЗАДАЧА  ПРО  МАССИВ
//////////////////////////////////////////////////////////////////////////////
package com.geekbrains.training.homework4;

import com.geekbrains.training.homework4.exceptions.MyArrayDataException;
import com.geekbrains.training.homework4.exceptions.MyArraySizeException;

public class MainApp {
    public static void main(String[] args) {
        final String ANSI_RESET = "\u001B[0m";
        final String ANSI_RED = "\u001B[31m";
        final String ANSI_GREEN = "\u001B[32m";

        String[][] myArray = new String[4][4];

        for (int i = 0; i < myArray.length; i++) {
            for (int j = 0; j < myArray[0].length; j++) {
                if (i == 1 && j == 1) {
                    myArray[i][j] = "16L"; //"0.25" "Test of number conversion", "S", null
                } else {
                    myArray[i][j] = String.valueOf(i * 2 + j * 3);
                }
                System.out.print(myArray[i][j] + " ");
            }
            System.out.println();
        }

        try {
            System.out.printf(ANSI_GREEN + "Сумма элементов массива = %d %n" + ANSI_RESET, sumArray(myArray));
        } catch (MyArraySizeException | MyArrayDataException e) {
            System.out.println(ANSI_RED + e.getMessage() + ANSI_RESET);
        }
    }

    private static int sumArray(String[][] inArray) {
        final int NEED_ARRAY_SIZE = 4;

        if (inArray.length != NEED_ARRAY_SIZE || inArray[0].length != NEED_ARRAY_SIZE) {
            throw new MyArraySizeException(NEED_ARRAY_SIZE, inArray.length, inArray[0].length);
        }

        int sum = 0;
        for (int i = 0; i < inArray.length; i++) {
            for (int j = 0; j < inArray[0].length; j++) {
                try {
                    sum = sum + Integer.parseInt(inArray[i][j]);
                } catch (NumberFormatException e) {
                    throw new MyArrayDataException(i, j, inArray[i][j]);
                }
            }
        }
        return sum;
    }
}



package com.geekbrains.training.homework4.exceptions;

public class MyArrayDataException extends RuntimeException {
    private int size1, size2;
    private String arrElement;

    public int getSize1() {
        return size1;
    }

    public int getSize2() {
        return size2;
    }

    public String getArrElement() {
        return arrElement;
    }

    public MyArrayDataException(int size1, int size2, String arrElement) {
        super("Ошибка в ячейке [" + size1 + "][" + size2 + "]: не удалось преобразовать в число (тип int) строку " + arrElement + "!");
        this.size1 = size1;
        this.size2 = size2;
        this.arrElement = arrElement;
    }
}



package com.geekbrains.training.homework4.exceptions;

public class MyArraySizeException extends RuntimeException {
    private int max_array_size, size1, size2;

    public int getSize1() {
        return size1;
    }

    public int getSize2() {
        return size2;
    }

    public int getMax_array_size() {
        return max_array_size;
    }

    public MyArraySizeException(int max_array_size, int size1, int size2) {
        super("Ошибка: разрешена работа только с массивом " + max_array_size + "х" + max_array_size + ", передан массив неразрешённого размера " + size1 + "x" + size2);
        this.size1 = size1;
        this.size2 = size2;
        this.max_array_size = max_array_size;
    }
}





//////////////////////////////////////////////////////////////////////////////
//   П Р О Е К Т
//////////////////////////////////////////////////////////////////////////////
package com.geekbrains.training.homework;

import com.geekbrains.training.homework.entities.Task;
import com.geekbrains.training.homework.services.TaskService;

public class MainApp {
    public static void main(String[] args) {
        System.out.println("+-------------------------------------------+");
        System.out.println("| Проверка создания задачи через класс Task |");
        System.out.println("+-------------------------------------------+");
        Task task = new Task(1L, "Task_1", "Owner_1", "Executor_1", "Create task 1", Task.Status.CREATED);
        System.out.println(task);
        System.out.println(task.getId());
        System.out.println(task.getTitle());
        System.out.println();

        System.out.println("+------------------------------------+");
        System.out.println("| Проверка работы equals класса Task |");
        System.out.println("+------------------------------------+");
        Task another1 = new Task(1L, "Task_1", "Owner_1", "Executor_1", "Create task 1", Task.Status.CREATED);
        Task another2 = new Task(2L, "Task_2", "Owner_2", "Executor_2", "Create task 2", Task.Status.CREATED);
        System.out.println(task.equals(task)); // сверяем сам с собой
        System.out.println(task.equals(another1));
        System.out.println(task.equals(another2));
        System.out.println(task.equals(null)); // если объект не существует
        System.out.println();

        System.out.println("+-----------------+");
        System.out.println("| Проверка поиска |");
        System.out.println("+-----------------+");
        TaskService taskService = new TaskService();
        taskService.printList();
        taskService.findTaskById(null);
        taskService.findTaskById(888L);
        taskService.findTaskById(0L);
        taskService.isTaskExist(0L, "Task0");
        taskService.findTaskById(1L);
        taskService.isTaskExist(1L, "Task1");
        System.out.println();

        System.out.println("+---------------------+");
        System.out.println("| Проверка добавления |");
        System.out.println("+---------------------+");
        taskService.addTask(1L, "Task1", "owner1", "executor1", "Create task 1");
        System.out.println("Повторное добавление такой же записи:");
        taskService.addTask(1L, "Task1", "owner1", "executor1", "Create task 1");
        System.out.println("Добавление id = NULL:");
        taskService.addTask(null, "Task1", "owner1", "executor1", "Create task 1");
        taskService.findTaskById(1L);
        taskService.printList();
        System.out.println();

        System.out.println("+---------------------+");
        System.out.println("| Проверка обновления |");
        System.out.println("+---------------------+");
        Task newTask = null;
        taskService.editTask(newTask);
        newTask = taskService.findTaskById(1L);
        newTask.setOwner("NewOwner1");
        newTask.setExecutor("NewExecutor1");
        newTask.setDescription("NewDescription1");
        newTask.setStatus(Task.Status.REJECTED);
        taskService.editTask(newTask);
        newTask = new Task(888L, "Task_1", "Owner_1", "Executor_1", "Create task 1", Task.Status.CLOSED);
        taskService.editTask(newTask);
        System.out.println();

        System.out.println("+-------------------+");
        System.out.println("| Проверка удаления |");
        System.out.println("+-------------------+");
        taskService.printList();
        taskService.delTask(1L);
        taskService.delTask(1L);
        taskService.printList();
        System.out.println();

        System.out.println("+-------------------------------------+");
        System.out.println("| Проверка добавления с переполнением |");
        System.out.println("+-------------------------------------+");
        for (int i = 0; i < 12; i++) {
            taskService.addTask((long)i, "Task" + i, "NewOwner" + i, "NewExecutor" + i, "Create new task " + i);
        }
        taskService.printList();
    }
}




package com.geekbrains.training.homework.services;

import com.geekbrains.training.homework.entities.Task;
import com.geekbrains.training.homework.exceptions.TaskAlreadyExist;
import com.geekbrains.training.homework.exceptions.TaskListFullException;
import com.geekbrains.training.homework.exceptions.TaskNoFound;

public class TaskService {
    private static final String ANSI_RESET = "\u001B[0m";
    private static final String ANSI_RED = "\u001B[31m";
    private static final String ANSI_GREEN = "\u001B[32m";

    private TaskRepository taskRepository;

    public TaskService() {
        taskRepository = new TaskRepository();
    }

    public void isTaskExist(Long id, String title) {
        if (taskRepository.isTaskExist(id, title)) {
            System.out.println(ANSI_GREEN + "Запись найдена [id = " + id + ", title = " + title + "]" + ANSI_RESET);
        } else {
            System.out.println(ANSI_RED + "Запись отсутствует [id = " + id + ", title = " + title + "]!" + ANSI_RESET);
        }
    }

    public Task findTaskById(Long id) {
        Task task = null;
        if (id == null) {
            System.out.println(ANSI_RED + "Ошибка поиска: не задан идентификатор!" + ANSI_RESET);
        } else {
            try {
                task = taskRepository.findTaskById(id);
                if (task == null) {
                    System.out.println(ANSI_RED + "Ошибка поиска: запись не существует [id = " + id + "]!" + ANSI_RESET);
                }
            } catch (TaskNoFound e) {
                System.out.println(ANSI_RED + "Ошибка поиска: запись не существует [id = " + id + "]!" + ANSI_RESET);
            }
        }
        return task;
    }

    public void addTask(Long id, String title, String owner, String executor, String description) {
        if (id == null) {
            System.out.println(ANSI_RED + "Ошибка: не задан идентификатор задачи!" + ANSI_RESET);
            return;
        }
        try {
            int indexArray = taskRepository.addTask(id, title, owner, executor, description);
            System.out.println(ANSI_GREEN + "Запись успешно добавлена [id = " + id + ", title = " + title + "] в ячейку массива = " + indexArray + ANSI_RESET);
        } catch (TaskAlreadyExist | TaskListFullException e) {
            System.out.println(ANSI_RED + e.getMessage() + ANSI_RESET);
        }
    }

    public void editTask(Task newTask) {
        if (newTask == null) {
            System.out.println(ANSI_RED + "Ошибка обновления: задача отсутствует!" + ANSI_RESET);
            return;
        }
        if (newTask.getId() == null) {
            System.out.println(ANSI_RED + "Ошибка обновления: отсутствует идентификатор задачи!" + ANSI_RESET);
            return;
        }
        if (newTask.getTitle() == null) {
            System.out.println(ANSI_RED + "Ошибка обновления: отсутствует название задачи!" + ANSI_RESET);
            return;
        }
        try {
            int indexArray = taskRepository.editTask(newTask);
            System.out.println(ANSI_GREEN + "Запись успешно обновлена [id = " + newTask.getId() + ", title = " + newTask.getTitle() + "] в ячейке массива = " + indexArray + ANSI_RESET);
        } catch (TaskNoFound e) {
            System.out.println(ANSI_RED + "Ошибка обновления: запись не существует [id = " + newTask.getId() + ", title = " + newTask.getTitle() + "]!" + ANSI_RESET);
        }
    }

    public void delTask(Long id) throws TaskNoFound {
        try {
            taskRepository.delTask(id);
            System.out.println(ANSI_GREEN + "Запись успешно удалена [id = " + id + "]" + ANSI_RESET);
        } catch (TaskNoFound e) {
            System.out.println(ANSI_RED + "Ошибка удаления: нет такой записи [id = " + id + "]!" + ANSI_RESET);
        }
    }

    public void printList() {
        taskRepository.printList();
    }
}




package com.geekbrains.training.homework;

import com.geekbrains.training.homework.entities.Task;

public interface TaskInterface {
    void prepare();

    boolean isTaskExist(Long id, String title);

    Task findTaskById(Long id);

    int addTask(Long id, String title, String owner, String executor, String description);

    int editTask(Task newTask);

    void delTask(Long Id);

    void printList();
}




package com.geekbrains.training.homework.services;

import com.geekbrains.training.homework.TaskInterface;
import com.geekbrains.training.homework.entities.Task;
import com.geekbrains.training.homework.exceptions.TaskAlreadyExist;
import com.geekbrains.training.homework.exceptions.TaskListFullException;
import com.geekbrains.training.homework.exceptions.TaskNoFound;

public class TaskRepository implements TaskInterface {
    private Task[] tasks;

    TaskRepository() {
        prepare();
    } // видимость в пределах пакета

    @Override
    public void prepare() {
        this.tasks = new Task[10];
        for (int i = 0; i < tasks.length; i += 2) {
            tasks[i] = new Task((long)i, "Task" + i, "Owner" + i, "Executor" + i, "Create task " + i, Task.Status.CREATED);
        }
    }

    @Override
    public boolean isTaskExist(Long id, String title) {
        for (Task task : tasks) {
            if (task != null && task.getId().equals(id) && task.getTitle().equals(title)) {
                return true;
            }
        }
        return false;
    }

    @Override
    public Task findTaskById(Long id) {
        for (Task task : tasks) {
            if (task != null && task.getId().equals(id)) {
                return task;
            }
        }
        return null;
    }

    @Override
    public int addTask(Long id, String title, String owner, String executor, String description) {
        for (int i = 0; i < this.tasks.length; i++) {
            if (tasks[i] != null && tasks[i].getId().equals(id) && tasks[i].getTitle().equals(title)) {
                throw new TaskAlreadyExist(i);
            }
        }

        for (int i = 0; i < this.tasks.length; i++) {
            if (tasks[i] == null) {
                tasks[i] = new Task(id, title, owner, executor, description, Task.Status.CREATED);
                return i;
            }
        }
        throw new TaskListFullException();
    }

    @Override
    public int editTask(Task newTask) {
        if (newTask == null || newTask.getId() == null || newTask.getTitle() == null) {
            throw new TaskNoFound();
        }
        for (int i = 0; i < this.tasks.length; i++) {
            if (tasks[i] != null && tasks[i].getId().equals(newTask.getId()) && tasks[i].getTitle().equals(newTask.getTitle())) {
                tasks[i] = newTask;
                return i;
            }
        }
        throw new TaskNoFound();
    }

    @Override
    public void delTask(Long id) {
        for (int i = 0; i < this.tasks.length; i++) {
            if (tasks[i] != null && tasks[i].getId().equals(id)) {
                tasks[i] = null;
                return; // считаем, что не может быть несколько задач с одинаковым id
            }
        }
        throw new TaskNoFound();
    }

    @Override
    public void printList() {
        System.out.println("Список задач:");
        for (Task task : tasks) {
            if (task != null) {
                System.out.println(task);
            }
        }
    }
}




package com.geekbrains.training.homework.entities;

public class Task {
    public enum Status {
        CREATED("Создана"), CLOSED("Закрыта"), REJECTED("Отклонена");

        private String rusTitle;

        Status(String rusTitle) {
            this.rusTitle = rusTitle;
        }

        public String getRusTitle() {
            return rusTitle;
        }
    }

    private Long id;
    private String title;
    private String owner;
    private String executor;
    private String description;
    private Status status;

    // конструктор класса
    public Task(Long id, String title, String owner, String executor, String description, Status status) {
        this.id = id;
        this.title = title;
        this.owner = owner;
        this.executor = executor;
        this.description = description;
        this.status = status;
    }

    @Override
    public String toString() {
        return String.format("Задача [id = %d, title = %s, owher = %s, executor = %s, description = %s, status = %s]", id, title, owner, executor, description, status.getRusTitle());
    }

    // если переопределяем equals, то необходимо также синхронно переопределить hashCode
    @Override
    public boolean equals(Object o) {
        if (o == null || !(o instanceof Task)) {
            return false;
        }
        if (this == o) {
            return true;
        }
        Task another = (Task) o;
        return this.id.equals(another.id) && this.title.equals(another.title);
    }

    // если объекты равны по equals, то их hashCode тоже должны быть равны
    // если объекты НЕ равны по equals, то их hashCode желательно тоже НЕ должны совпадать
    @Override
    public int hashCode() {
        return id.intValue() + title.hashCode();
    }

    public Long getId() {
        return id;
    }

    public String getTitle() {
        return title;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public void setOwner(String owner) {
        this.owner = owner;
    }

    public void setExecutor(String executor) {
        this.executor = executor;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public void setStatus(Status status) {
        this.status = status;
    }
}




package com.geekbrains.training.homework.exceptions;

public class TaskNoFound extends RuntimeException {
}




package com.geekbrains.training.homework.exceptions;

public class TaskListFullException extends RuntimeException {
    public TaskListFullException() {
        super("Ошибка добавления: список задач заполнен!");
    }
}




package com.geekbrains.training.homework.exceptions;

public class TaskAlreadyExist extends RuntimeException {
    private int indexArray;

    public int getIndexArray() {
        return indexArray;
    }

    public TaskAlreadyExist(int indexArray) {
        super("Ошибка: такая запись уже существует в массиве по индексу "+indexArray);
        this.indexArray = indexArray;
    }
}


