//////////////////////////////////////////////////////////////////////////////////
// ЗАДАЧА ПРО ФРУКТЫ
//////////////////////////////////////////////////////////////////////////////////

package com.geekbrains.training.homework5.Fruits;
public class Fruit {
    private float weigth;
    private String name;

    public float getWeigth() {
        return weigth;
    }

    public String getName() {
        return name;
    }

    public void setWeigth(float weigth) {
        this.weigth = weigth;
    }

    public void setName(String name) {
        this.name = name;
    }

    public static boolean compare(Fruit fruit1, Fruit fruit2) {
        if (Math.abs(fruit1.getWeigth() - fruit2.getWeigth()) < 0.0001f) {
            return true;
        }
        return false;
    }
}



package com.geekbrains.training.homework5.Fruits;
public class Apple extends Fruit {
    public Apple() {
        super.setWeigth(1f);
        super.setName("Яблоко");
    }
}



package com.geekbrains.training.homework5.Fruits;
public class Orange extends Fruit {
    public Orange() {
        super.setWeigth(1.5f);
        super.setName("Апельсин");
    }
}



package com.geekbrains.training.homework5;
import com.geekbrains.training.homework5.Fruits.Fruit;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
// считаем ящик безразмерным и не имеющим веса
public class BoxGen<N extends Fruit> {
    private List<N> list = new ArrayList<>();

    public void addFruit(N fruit) {
        list.add(fruit);
    }

    public int getCountFruits() {
        return list.size();
    }

    public float getWeight() {
        if (list.size() == 0) {
            return 0f;
        }
        return list.size() * list.get(0).getWeigth();
    }

    public String getFruitName() {
        if (list.size() == 0) {
            return "Ящик пустой - нельзя определить, какой фрукт в нём хранится!";
        }
        return list.get(0).getName();
    }

    public boolean compare(BoxGen otherBox) {
        if (Math.abs(this.getWeight() - otherBox.getWeight()) < 0.0001f) {
            return true;
        }
        return false;
    }

    public void moveAllFruitsToOtherBox(BoxGen otherBox) {
        if (otherBox.equals(this)) {
            System.out.println("Задан один и тот же ящик - нельзя пересыпать ящик сам в себя!");
            return;
        }
        if (list.size() == 0) {
            System.out.println("Текущий ящик пустой - пересыпать нечего!");
            return;
        }
        if (otherBox.getCountFruits() == 0) {
            System.out.println("Ящик, в который собираемся пересыпать - пустой (неизвестно для каких фруктов), пересыпать нельзя!");
            return;
        }
        if (!list.get(0).equals(otherBox.list.get(0))) {
            System.out.println("В ящиках разные фрукты: " + getFruitName() + " в текущем и " + otherBox.getFruitName() + " в другом - пересыпать нельзя!");
            return;
        }

        Iterator<N> fruitIterator = list.iterator();
        while (fruitIterator.hasNext()) {
            N fruit = fruitIterator.next();
            otherBox.addFruit(fruit);
            fruitIterator.remove();
        }
        System.out.println("Ящик успешно пересыпан!");
    }
}



package com.geekbrains.training.homework5;
import com.geekbrains.training.homework5.Fruits.Apple;
import com.geekbrains.training.homework5.Fruits.Fruit;
import com.geekbrains.training.homework5.Fruits.Orange;
public class MainApp {
    public static void main(String[] args) {
        System.out.println("+----------------------------------------+");
        System.out.println(" СОЗДАДИМ ФРУКТЫ                         |");
        System.out.println("+----------------------------------------+");
        Orange orange = new Orange();
        Apple apple = new Apple();
        System.out.println(orange.getName() + ": вес = " + orange.getWeigth());
        System.out.println(apple.getName() + ": вес = " + apple.getWeigth());
        System.out.println("Вес яблока (" + apple.getWeigth() + ") = весу апельсина (" + orange.getWeigth() + "): " + Fruit.compare(apple, orange));
        System.out.println("Вес апельсина (" + orange.getWeigth() + ") = весу яблока (" + apple.getWeigth() + "): " + Fruit.compare(orange, apple));
        System.out.println("Вес апельсина (" + orange.getWeigth() + ") = весу апельсина (" + orange.getWeigth() + "): " + Fruit.compare(orange, orange));
        System.out.println("Вес яблока (" + apple.getWeigth() + ") = весу яблока (" + apple.getWeigth() + "): " + Fruit.compare(apple, apple));
        System.out.println();

        // ящики для фруктов
        BoxGen<Orange> boxOrangeA = new BoxGen<>();
        BoxGen<Apple> boxAppleA = new BoxGen<>();
        BoxGen<Orange> boxOrangeB = new BoxGen<>();
        BoxGen<Apple> boxAppleB = new BoxGen<>();

        // фрукты накидываем в соответствующие ящики случайным образом
        double pickBox;
        for (int i = 0; i < 64; i++) {
            pickBox = Math.random();
            if (pickBox <= 0.25) {
                boxOrangeA.addFruit(orange);
            } else if (pickBox > 0.25 && pickBox <= 0.5) {
                boxAppleA.addFruit(apple);
            } else if (pickBox > 0.5 && pickBox <= 0.75) {
                boxOrangeB.addFruit(orange);
            } else {
                boxAppleB.addFruit(apple);
            }
        }

        System.out.println("+----------------------------------------+");
        System.out.println("| РЕЗУЛЬТАТ ЗАПОЛНЕНИЯ ЯЩИКОВ С ФРУКТАМИ |");
        System.out.println("+----------------------------------------+");
        System.out.println(boxOrangeA.getFruitName() + ", ящик А: " + boxOrangeA.getCountFruits() + " шт., вес = " + boxOrangeA.getWeight());
        System.out.println(boxOrangeB.getFruitName() + ", ящик В: " + boxOrangeB.getCountFruits() + " шт., вес = " + boxOrangeB.getWeight());
        System.out.println(boxAppleA.getFruitName() + ", ящик А: " + boxAppleA.getCountFruits() + " шт., вес = " + boxAppleA.getWeight());
        System.out.println(boxAppleB.getFruitName() + ", ящик В: " + boxAppleB.getCountFruits() + " шт., вес = " + boxAppleB.getWeight());
        System.out.println("--------");
        System.out.println("Вес ящика апельсинов А (" + boxOrangeA.getWeight() + ") = весу ящика апельсинов A (" + boxOrangeA.getWeight() + "): " + boxOrangeA.compare(boxOrangeA));
        System.out.println("Вес ящика яблок А (" + boxAppleA.getWeight() + ") = весу ящика яблок A (" + boxAppleA.getWeight() + "): " + boxAppleA.compare(boxAppleA));
        System.out.println("Вес ящика апельсинов А (" + boxOrangeA.getWeight() + ") = весу ящика апельсинов B (" + boxOrangeB.getWeight() + "): " + boxOrangeA.compare(boxOrangeB));
        System.out.println("Вес ящика апельсинов А (" + boxOrangeA.getWeight() + ") = весу ящика яблок A (" + boxAppleA.getWeight() + "): " + boxOrangeA.compare(boxAppleA));
        System.out.println("Вес ящика яблок B (" + boxAppleB.getWeight() + ") = весу ящика апельсинов B (" + boxOrangeB.getWeight() + "): " + boxAppleB.compare(boxOrangeB));
        System.out.println();

        System.out.println("+----------------------------------------+");
        System.out.println("| ПЕРЕСЫПКА ФРУКТОВ                      |");
        System.out.println("+----------------------------------------+");
        boxOrangeA.moveAllFruitsToOtherBox(boxAppleB);
        boxOrangeA.moveAllFruitsToOtherBox(boxOrangeB);
        boxAppleA.moveAllFruitsToOtherBox(boxOrangeB);
        boxAppleA.moveAllFruitsToOtherBox(boxAppleB);

        boxAppleA.moveAllFruitsToOtherBox(boxAppleA);
        boxAppleB.moveAllFruitsToOtherBox(boxAppleB);
        boxOrangeA.moveAllFruitsToOtherBox(boxOrangeB);
        System.out.println(boxOrangeA.getFruitName());
        System.out.println("Вес пустого ящика = " + boxOrangeA.getWeight());
        System.out.println("--------");
        System.out.println("Апельсины, ящик А: " + boxOrangeA.getCountFruits() + " шт., вес = " + boxOrangeA.getWeight());
        System.out.println("Апельсины, ящик В: " + boxOrangeB.getCountFruits() + " шт., вес = " + boxOrangeB.getWeight());
        System.out.println("Яблоки, ящик А: " + boxAppleA.getCountFruits() + " шт., вес = " + boxAppleA.getWeight());
        System.out.println("Яблоки, ящик В: " + boxAppleB.getCountFruits() + " шт., вес = " + boxAppleB.getWeight());
    }
}





//////////////////////////////////////////////////////////////////////////////////
// П Р О Е К Т
//////////////////////////////////////////////////////////////////////////////////

package com.geekbrains.training.homework.exceptions;
public class TaskNoFound extends RuntimeException {
    public TaskNoFound(String message) {
        super("Ошибка: " + message + "!");
    }
}



package com.geekbrains.training.homework.exceptions;
public class TaskAlreadyExist extends RuntimeException {
    private int indexArray;
    private Long id;
    private String title;

    public int getIndexArray() {
        return indexArray;
    }

    public Long getId() {
        return id;
    }

    public String getTitle() {
        return title;
    }

    public TaskAlreadyExist(Long id, String title, int indexArray) {
        super("Ошибка: такая запись [id = " + id + ", title = " + title + "] уже существует в ячейке " + indexArray);
        this.indexArray = indexArray;
        this.id = id;
        this.title = title;
    }
}



package com.geekbrains.training.homework.entities;
public class Task {
    public enum Status {
        CREATED("Создана"), CLOSED("Закрыта"), REJECTED("Отклонена");

        private String rusTitle;

        Status(String rusTitle) {
            this.rusTitle = rusTitle;
        }

        public String getRusTitle() {
            return rusTitle;
        }
    }

    private Long id;
    private String title;
    private String owner;
    private String executor;
    private String description;
    private Status status;

    // конструктор класса
    public Task(Long id, String title, String owner, String executor, String description, Status status) {
        this.id = id;
        this.title = title;
        this.owner = owner;
        this.executor = executor;
        this.description = description;
        this.status = status;
    }

    @Override
    public String toString() {
        return String.format("Задача [id = %d, title = %s, owher = %s, executor = %s, description = %s, status = %s]", id, title, owner, executor, description, status.getRusTitle());
    }

    // если переопределяем equals, то необходимо также синхронно переопределить hashCode
    @Override
    public boolean equals(Object o) {
        if (o == null || !(o instanceof Task)) {
            return false;
        }
        if (this == o) {
            return true;
        }
        Task another = (Task) o;
        return this.id.equals(another.id) && this.title.equals(another.title);
    }

    // если объекты равны по equals, то их hashCode тоже должны быть равны
    // если объекты НЕ равны по equals, то их hashCode желательно тоже НЕ должны совпадать
    @Override
    public int hashCode() {
        return id.intValue() + title.hashCode();
    }

    public Long getId() {
        return id;
    }

    public String getTitle() {
        return title;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public void setOwner(String owner) {
        this.owner = owner;
    }

    public void setExecutor(String executor) {
        this.executor = executor;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public void setStatus(Status status) {
        this.status = status;
    }
}



package com.geekbrains.training.homework;
import com.geekbrains.training.homework.entities.Task;
public interface TaskInterface {
    void prepare();

    boolean isTaskExist(Long id, String title);

    Task findTaskById(Long id);

    int addTask(Long id, String title, String owner, String executor, String description);

    int editTask(Task newTask);

    void delTask(Long Id);

    void printList();
}



package com.geekbrains.training.homework.services;
import com.geekbrains.training.homework.TaskInterface;
import com.geekbrains.training.homework.entities.Task;
import com.geekbrains.training.homework.exceptions.TaskAlreadyExist;
import com.geekbrains.training.homework.exceptions.TaskNoFound;
import java.util.ArrayList;
import java.util.List;
public class TaskRepository implements TaskInterface {
    private List<Task> tasks = new ArrayList<>();

    TaskRepository() {
        prepare();
    } // видимость в пределах пакета

    @Override
    public void prepare() {
        for (int i = 0; i < 10; i += 2) {
            tasks.add(new Task((long) i, "Task" + i, "Owner" + i, "Executor" + i, "Create task " + i, Task.Status.CREATED));
        }
    }

    @Override
    public boolean isTaskExist(Long id, String title) {
        for (Task task : tasks) {
            if (task.getId().equals(id) && task.getTitle().equals(title)) {
                return true;
            }
        }
        return false;
    }

    @Override
    public Task findTaskById(Long id) {
        if (id == null) {
            throw new TaskNoFound("нельзя найти запись - нет идентификатора задачи");
        }
        for (Task task : tasks) {
            if (task.getId().equals(id)) {
                return task;
            }
        }
        return null;
    }

    @Override
    public int addTask(Long id, String title, String owner, String executor, String description) {
        if (id == null) {
            throw new TaskNoFound("нельзя добавить задачу - нет идентификатора");
        }
        if (title == null) {
            throw new TaskNoFound("нельзя добавить задачу - нет названия");
        }
        for (Task task : tasks) {
            if (task.getId().equals(id) && task.getTitle().equals(title)) {
                throw new TaskAlreadyExist(id, title, tasks.indexOf(task));
            }
        }
        tasks.add(new Task(id, title, owner, executor, description, Task.Status.CREATED));
        return tasks.size() - 1;
    }

    @Override
    public int editTask(Task newTask) {
        if (newTask == null) {
            throw new TaskNoFound("нельзя редактировать задачу - объект пустой");
        }
        if (newTask.getId() == null) {
            throw new TaskNoFound("нельзя редактировать задачу - нет идентификатора");
        }
        if (newTask.getTitle() == null) {
            throw new TaskNoFound("нельзя редактировать задачу - нет названия");
        }

        for (Task task : tasks) {
            if (task.getId().equals(newTask.getId()) && task.getTitle().equals(newTask.getTitle())) {
                task = newTask;
                return tasks.indexOf(task);
            }
        }
        throw new TaskNoFound("нельзя редактировать задачу - нет такой в репозитории [id = " + newTask.getId() + ", title = " + newTask.getTitle() + "]");
    }

    @Override
    public void delTask(Long id) {
        if (id == null) {
            throw new TaskNoFound("нельзя удалить задачу - нет идентификатора");
        }
        for (int i = 0; i < tasks.size(); i++) {
            if (tasks.get(i).getId().equals(id)) {
                tasks.remove(i);
                return; // пока считаем, что не может быть несколько задач с одинаковым id
            }
        }
        throw new TaskNoFound("нельзя удалить задачу - нет такой в репозитории");
    }

    @Override
    public void printList() {
        System.out.println("Список задач:");
        for (Task task : tasks) {
            if (task != null) {
                System.out.println(task);
            }
        }
    }
}



package com.geekbrains.training.homework.services;
import com.geekbrains.training.homework.entities.Task;
import com.geekbrains.training.homework.exceptions.TaskAlreadyExist;
import com.geekbrains.training.homework.exceptions.TaskNoFound;
public class TaskService {
    private static final String ANSI_RESET = "\u001B[0m";
    private static final String ANSI_RED = "\u001B[31m";
    private static final String ANSI_GREEN = "\u001B[32m";

    private TaskRepository taskRepository;

    public TaskService() {
        taskRepository = new TaskRepository();
    }

    public void isTaskExist(Long id, String title) {
        if (taskRepository.isTaskExist(id, title)) {
            System.out.println(ANSI_GREEN + "Задача найдена [id = " + id + ", title = " + title + "]" + ANSI_RESET);
        } else {
            System.out.println(ANSI_RED + "Задача отсутствует [id = " + id + ", title = " + title + "]!" + ANSI_RESET);
        }
    }

    public Task findTaskById(Long id) {
        Task task = null;
        try {
            task = taskRepository.findTaskById(id);
            if (task == null) {
                System.out.println(ANSI_RED + "Задача отсутствует [id = " + id + "]!" + ANSI_RESET);
            } else {
                System.out.println(ANSI_GREEN + "Задача найдена [id = " + id + "]!" + ANSI_RESET);
            }
        } catch (TaskNoFound e) {
            System.out.println(ANSI_RED + e.getMessage() + ANSI_RESET);
        }
        return task;
    }

    public void addTask(Long id, String title, String owner, String executor, String description) {
        try {
            int indexListElement = taskRepository.addTask(id, title, owner, executor, description);
            System.out.println(ANSI_GREEN + "Задача успешно добавлена [id = " + id + ", title = " + title + "] в ячейку = " + indexListElement + ANSI_RESET);
        } catch (TaskAlreadyExist | TaskNoFound e) {
            System.out.println(ANSI_RED + e.getMessage() + ANSI_RESET);
        }
    }

    public void editTask(Task newTask) {
        try {
            int indexListElement = taskRepository.editTask(newTask);
            System.out.println(ANSI_GREEN + "Задача успешно обновлена [id = " + newTask.getId() + ", title = " + newTask.getTitle() + "] в ячейке " + indexListElement + ANSI_RESET);
        } catch (TaskNoFound e) {
            System.out.println(ANSI_RED + e.getMessage() + ANSI_RESET);
        }
    }

    public void delTask(Long id) throws TaskNoFound {
        try {
            taskRepository.delTask(id);
            System.out.println(ANSI_GREEN + "Задача успешно удалена [id = " + id + "]" + ANSI_RESET);
        } catch (TaskNoFound e) {
            System.out.println(ANSI_RED + e.getMessage() + ANSI_RESET);
        }
    }

    public void printList() {
        taskRepository.printList();
    }
}



package com.geekbrains.training.homework;
import com.geekbrains.training.homework.entities.Task;
import com.geekbrains.training.homework.services.TaskService;
public class MainApp {
    public static void main(String[] args) {
        System.out.println("+-------------------------------------------+");
        System.out.println("| Проверка создания задачи через класс Task |");
        System.out.println("+-------------------------------------------+");
        Task task = new Task(1L, "Task_1", "Owner_1", "Executor_1", "Create task 1", Task.Status.CREATED);
        System.out.println(task);
        System.out.println(task.getId());
        System.out.println(task.getTitle());
        System.out.println();

        System.out.println("+------------------------------------+");
        System.out.println("| Проверка работы equals класса Task |");
        System.out.println("+------------------------------------+");
        Task another1 = new Task(1L, "Task_1", "Owner_1", "Executor_1", "Create task 1", Task.Status.CREATED);
        Task another2 = new Task(2L, "Task_2", "Owner_2", "Executor_2", "Create task 2", Task.Status.CREATED);
        System.out.println(task.equals(task)); // сверяем сам с собой
        System.out.println(task.equals(another1));
        System.out.println(task.equals(another2));
        System.out.println(task.equals(null)); // если объект не существует
        System.out.println();

        // создание репозитория
        TaskService taskService = new TaskService();
        taskService.printList();
        System.out.println("+-----------------------------+");
        System.out.println("| Проверка поиска isTaskExist |");
        System.out.println("+-----------------------------+");
        taskService.isTaskExist(0L, "Task0");
        taskService.isTaskExist(1L, "Task1");
        taskService.isTaskExist(null, "Task2");
        taskService.isTaskExist(2L, null);
        System.out.println();

        System.out.println("+-----------------------------+");
        System.out.println("| Проверка поиска findTaskById |");
        System.out.println("+-----------------------------+");
        taskService.findTaskById(null);
        taskService.findTaskById(888L);
        taskService.findTaskById(0L);
        System.out.println();

        System.out.println("+---------------------+");
        System.out.println("| Проверка добавления |");
        System.out.println("+---------------------+");
        taskService.addTask(1L, "Task1", "owner1", "executor1", "Create task 1");
        System.out.println("Повторное добавление такой же записи:");
        taskService.addTask(1L, "Task1", "owner1", "executor1", "Create task 1");
        System.out.println("Добавление id = NULL:");
        taskService.addTask(null, "Task1", "owner1", "executor1", "Create task 1");
        System.out.println("Добавление title = NULL:");
        taskService.addTask(10L, null, "owner10", "executor10", "Create task 10");
        taskService.printList();
        System.out.println();

        System.out.println("+---------------------+");
        System.out.println("| Проверка обновления |");
        System.out.println("+---------------------+");
        Task newTask = null;
        taskService.editTask(newTask);
        newTask = taskService.findTaskById(1L);
        newTask.setOwner("NewOwner1");
        newTask.setExecutor("NewExecutor1");
        newTask.setDescription("NewDescription1");
        newTask.setStatus(Task.Status.REJECTED);
        taskService.editTask(newTask);
        taskService.editTask(new Task(888L, "Task_1", "Owner_1", "Executor_1", "Create task 1", Task.Status.CLOSED));
        taskService.printList();
        System.out.println();

        System.out.println("+-------------------+");
        System.out.println("| Проверка удаления |");
        System.out.println("+-------------------+");
        taskService.delTask(null);
        taskService.delTask(1L);
        taskService.delTask(1L);
        taskService.printList();
        System.out.println();

        System.out.println("+-------------------------------------+");
        System.out.println("| Проверка добавления с переполнением |");
        System.out.println("+-------------------------------------+");
        for (int i = 0; i < 12; i++) {
            taskService.addTask((long) i, "Task" + i, "NewOwner" + i, "NewExecutor" + i, "Create new task " + i);
        }
        taskService.printList();
    }
}