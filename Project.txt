///////////////////////////////////////////////////////////////////////////////////////
//  П Р О Е К Т
///////////////////////////////////////////////////////////////////////////////////////

package com.geekbrains.training.homework.fonts;
public class Fonts {
    public enum Color {
        RESET("\033[0m"),

        // Regular Colors
        BLACK("\033[0;30m"),
        RED("\033[0;31m"),
        GREEN("\033[0;32m"),
        YELLOW("\033[0;33m"),
        BLUE("\033[0;34m"),
        MAGENTA("\033[0;35m"),
        CYAN("\033[0;36m"),
        WHITE("\033[0;37m"),

        // Bold
        BLACK_BOLD("\033[1;30m"),
        RED_BOLD("\033[1;31m"),
        GREEN_BOLD("\033[1;32m"),
        YELLOW_BOLD("\033[1;33m"),
        BLUE_BOLD("\033[1;34m"),
        MAGENTA_BOLD("\033[1;35m"),
        CYAN_BOLD("\033[1;36m"),
        WHITE_BOLD("\033[1;37m"),

        // Underline
        BLACK_UNDERLINED("\033[4;30m"),
        RED_UNDERLINED("\033[4;31m"),
        GREEN_UNDERLINED("\033[4;32m"),
        YELLOW_UNDERLINED("\033[4;33m"),
        BLUE_UNDERLINED("\033[4;34m"),
        MAGENTA_UNDERLINED("\033[4;35m"),
        CYAN_UNDERLINED("\033[4;36m"),
        WHITE_UNDERLINED("\033[4;37m"),

        // Background
        BLACK_BACKGROUND("\033[40m"),
        RED_BACKGROUND("\033[41m"),
        GREEN_BACKGROUND("\033[42m"),
        YELLOW_BACKGROUND("\033[43m"),
        BLUE_BACKGROUND("\033[44m"),
        MAGENTA_BACKGROUND("\033[45m"),
        CYAN_BACKGROUND("\033[46m"),
        WHITE_BACKGROUND("\033[47m"),

        // High Intensity
        BLACK_BRIGHT("\033[0;90m"),
        RED_BRIGHT("\033[0;91m"),
        GREEN_BRIGHT("\033[0;92m"),
        YELLOW_BRIGHT("\033[0;93m"),
        BLUE_BRIGHT("\033[0;94m"),
        MAGENTA_BRIGHT("\033[0;95m"),
        CYAN_BRIGHT("\033[0;96m"),
        WHITE_BRIGHT("\033[0;97m"),

        // Bold High Intensity
        BLACK_BOLD_BRIGHT("\033[1;90m"),
        RED_BOLD_BRIGHT("\033[1;91m"),
        GREEN_BOLD_BRIGHT("\033[1;92m"),
        YELLOW_BOLD_BRIGHT("\033[1;93m"),
        BLUE_BOLD_BRIGHT("\033[1;94m"),
        MAGENTA_BOLD_BRIGHT("\033[1;95m"),
        CYAN_BOLD_BRIGHT("\033[1;96m"),
        WHITE_BOLD_BRIGHT("\033[1;97m"),

        // High Intensity backgrounds
        BLACK_BACKGROUND_BRIGHT("\033[0;100m"),
        RED_BACKGROUND_BRIGHT("\033[0;101m"),
        GREEN_BACKGROUND_BRIGHT("\033[0;102m"),
        YELLOW_BACKGROUND_BRIGHT("\033[0;103m"),
        BLUE_BACKGROUND_BRIGHT("\033[0;104m"),
        MAGENTA_BACKGROUND_BRIGHT("\033[0;105m"),
        CYAN_BACKGROUND_BRIGHT("\033[0;106m"),
        WHITE_BACKGROUND_BRIGHT("\033[0;107m");

        private final String code;

        Color(String code) {
            this.code = code;
        }

        @Override
        public String toString() {
            return code;
        }
    }
}





package com.geekbrains.training.homework.exceptions;
public class TaskAlreadyExist extends RuntimeException {
    private Long id;
    private String title;

    public Long getId() {
        return id;
    }

    public String getTitle() {
        return title;
    }

    public TaskAlreadyExist(Long id, String title) {
        super("Ошибка: такая запись [id = " + id + ", title = " + title + "] уже существует!");
        this.id = id;
        this.title = title;
    }
}




package com.geekbrains.training.homework.exceptions;
public class TaskNoFound extends RuntimeException {
    public TaskNoFound(String message) {
        super("Ошибка: " + message + "!");
    }
}




package com.geekbrains.training.homework.entities;
public class Task {
    public enum Status {
        CREATED("Создана"), IN_WORK("В работе"), CLOSED("Закрыта"), REJECTED("Отклонена"), SUSPENDED("Приостановлена");;

        private String rusTitle;

        Status(String rusTitle) {
            this.rusTitle = rusTitle;
        }

        public String getRusTitle() {
            return rusTitle;
        }
    }

    private Long id;
    private String title;
    private String owner;
    private String executor;
    private String description;
    private Status status;

    // конструктор класса
    public Task(Long id, String title, String owner, String executor, String description, Status status) {
        this.id = id;
        this.title = title;
        this.owner = owner;
        this.executor = executor;
        this.description = description;
        this.status = status;
    }

    @Override
    public String toString() {
        return String.format("Задача [id = %d, title = %s, owher = %s, executor = %s, description = %s, status = %s]", id, title, owner, executor, description, status.getRusTitle());
    }

    // если переопределяем equals, то необходимо также синхронно переопределить hashCode
    @Override
    public boolean equals(Object o) {
        if (o == null || !(o instanceof Task)) {
            return false;
        }
        if (this == o) {
            return true;
        }
        Task another = (Task) o;
        return this.id.equals(another.id) && this.title.equals(another.title);
    }

    // если объекты равны по equals, то их hashCode тоже должны быть равны
    // если объекты НЕ равны по equals, то их hashCode желательно тоже НЕ должны совпадать
    @Override
    public int hashCode() {
        return id.intValue() + title.hashCode();
    }

    public Long getId() {
        return id;
    }

    public String getTitle() {
        return title;
    }

    public Status getStatus() {
        return status;
    }

    public String getOwner() {
        return owner;
    }

    public String getExecutor() {
        return executor;
    }

    public String getDescription() {
        return description;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public void setOwner(String owner) {
        this.owner = owner;
    }

    public void setExecutor(String executor) {
        this.executor = executor;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public void setStatus(Status status) {
        this.status = status;
    }
}




package com.geekbrains.training.homework;
import com.geekbrains.training.homework.entities.Task;
public interface TaskInterface {
    String getNameRepo();

    void prepare();

    boolean isTaskExist(Long id);

    boolean isTaskExist(Long id, String title);

    Task findTaskById(Long id);

    void addTask(Long id, String title, String owner, String executor, String description, Task.Status status);

    void editTask(Task newTask);

    void delTask(Long id);

    void printList();
}




package com.geekbrains.training.homework.services;
import com.geekbrains.training.homework.TaskInterface;
import com.geekbrains.training.homework.entities.Task;
import com.geekbrains.training.homework.exceptions.TaskAlreadyExist;
import com.geekbrains.training.homework.exceptions.TaskNoFound;
import java.util.*;
public class TaskRepository implements TaskInterface {
    private List<Task> tasks = new ArrayList<>();

    TaskRepository() {
        prepare();
    }

    List<Task> getTasks() {
        return tasks;
    }

    @Override
    public String getNameRepo() {
        return "Репозиторий: в оперативной памяти (List).";
    }

    @Override
    public void prepare() {
        // [min;max) - генератор в диапазоне
        final int MIN = 0;
        final int MAX = 4;
        for (int i = 0; i < 30; i += 2) {
            tasks.add(new Task((long) i, "Task" + i, "Owner" + i, "Executor" + i, "Create task " + i, Task.Status.values()[(int) ((Math.random() * (MAX - MIN)) + MIN)]));
        }
    }

    @Override
    public boolean isTaskExist(Long id) {
        for (Task task : tasks) {
            if (task.getId().equals(id)) {
                return true;
            }
        }
        return false;
    }

    @Override
    public boolean isTaskExist(Long id, String title) {
        for (Task task : tasks) {
            if (task.getId().equals(id) && task.getTitle().equals(title)) {
                return true;
            }
        }
        return false;
    }

    @Override
    public Task findTaskById(Long id) {
        if (id == null) {
            throw new TaskNoFound("нельзя найти запись - нет идентификатора задачи");
        }
        for (Task task : tasks) {
            if (task.getId().equals(id)) {
                return task;
            }
        }
        return null;
    }

    @Override
    public void addTask(Long id, String title, String owner, String executor, String description, Task.Status status) {
        if (id == null) {
            throw new TaskNoFound("нельзя добавить задачу - нет идентификатора");
        }
        if (title == null) {
            throw new TaskNoFound("нельзя добавить задачу - нет названия");
        }
        for (Task task : tasks) {
            if (task.getId().equals(id) && task.getTitle().equals(title)) {
                throw new TaskAlreadyExist(id, title);
            }
        }

        tasks.add(new Task(id, title, owner, executor, description, status == null ? Task.Status.CREATED : status));
    }

    @Override
    public void editTask(Task newTask) {
        if (newTask == null) {
            throw new TaskNoFound("нельзя редактировать задачу - объект пустой");
        }
        if (newTask.getId() == null) {
            throw new TaskNoFound("нельзя редактировать задачу - нет идентификатора");
        }
        if (newTask.getTitle() == null) {
            throw new TaskNoFound("нельзя редактировать задачу - нет названия");
        }

        for (Task task : tasks) {
            if (task.getId().equals(newTask.getId()) && task.getTitle().equals(newTask.getTitle())) {
                task = newTask;
                return;
            }
        }
        throw new TaskNoFound("нельзя редактировать задачу - нет такой в репозитории [id = " + newTask.getId() + ", title = " + newTask.getTitle() + "]");
    }

    @Override
    public void delTask(Long id) {
        if (id == null) {
            throw new TaskNoFound("нельзя удалить задачу - нет идентификатора");
        }
        for (int i = 0; i < tasks.size(); i++) {
            if (tasks.get(i).getId().equals(id)) {
                tasks.remove(i);
                return; // пока считаем, что не может быть несколько задач с одинаковым id
            }
        }
        throw new TaskNoFound("нельзя удалить задачу - нет такой в репозитории");
    }

    @Override
    public void printList() {
        if (tasks.size() == 0) {
            System.out.println("Репозитарий пустой!");
        } else {
            for (Task task : tasks) {
                if (task != null) {
                    System.out.println(task);
                }
            }
        }
    }
}




package com.geekbrains.training.homework.services;
import com.geekbrains.training.homework.TaskInterface;
import com.geekbrains.training.homework.entities.Task;
import com.geekbrains.training.homework.exceptions.TaskAlreadyExist;
import com.geekbrains.training.homework.exceptions.TaskNoFound;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class TaskRepoDB implements TaskInterface {
    private Connection connection;
    private Statement stmt;

    TaskRepoDB() {
        prepare();
    }

    @Override
    public String getNameRepo() {
        return "Репозиторий: БД " + connection.toString();
    }

    // получить список задач через коллекцию
    List<Task> getTasks() {
        List<Task> tasks = new ArrayList<>();
        try {
            connect();
            ResultSet rs = stmt.executeQuery("select * from tasks;");
            while (rs.next()) {
                Long id = Long.valueOf(rs.getString("id"));
                String title = rs.getString("title");
                String owner = rs.getString("owner");
                String executor = rs.getString("executor");
                String description = rs.getString("description");
                Task.Status status = Task.Status.valueOf(rs.getString("status"));

                tasks.add(new Task(id, title, owner, executor, description, status));
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            disconnect();
        }
        return tasks;
    }

    // подготовка репозитория
    @Override
    public void prepare() {
        // [min;max) - генератор в диапазоне
        final int MIN = 0;
        final int MAX = 4;
        String query;
        try {
            connect();
            stmt.executeUpdate("delete from tasks;");
            for (int i = 0; i < 20; i += 2) {
                query = "insert into tasks (id, title, owner, executor, description, status) " +
                        "values (" + i + ", '" + "Task" + i + "', '" + "Owner" + i + "', '" + "Executor" + i + "', '" + "Description" + i + "', '" + Task.Status.values()[(int) ((Math.random() * (MAX - MIN)) + MIN)] + "');";
                stmt.executeUpdate(query);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            disconnect();
        }
    }

    // проверка существования задачи по идентификатору
    @Override
    public boolean isTaskExist(Long id) {
        if (id == null) {
            throw new TaskNoFound("нельзя найти задачу - нет идентификатора");
        }

        boolean res = false;
        String query = "select count(1) from tasks where id = " + id + ";";
        try {
            connect();
            ResultSet rs = stmt.executeQuery(query);
            while (rs.next()) {
                res = rs.getInt(1) == 1;
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            disconnect();
        }
        return res;
    }

    // проверка существования задачи по идентификатору и названию
    @Override
    public boolean isTaskExist(Long id, String title) {
        if (id == null) {
            throw new TaskNoFound("нельзя найти задачу - нет идентификатора");
        }
        if (title == null) {
            throw new TaskNoFound("нельзя найти задачу - нет названия");
        }

        boolean res = false;
        String query = "select count(1) from tasks where id = " + id + " and title = '" + title + "';";
        try {
            connect();
            ResultSet rs = stmt.executeQuery(query);
            while (rs.next()) {
                res = rs.getInt(1) == 1;
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            disconnect();
        }
        return res;
    }

    // найти задачу по идентификатору
    @Override
    public Task findTaskById(Long inId) {
        if (inId == null) {
            throw new TaskNoFound("нельзя найти запись - нет идентификатора задачи");
        }
        Task task = null;
        String query = "select * from tasks where id = " + inId + ";";
        try {
            connect();
            ResultSet rs = stmt.executeQuery(query);
            while (rs.next()) {
                Long id = Long.valueOf(rs.getString("id"));
                String title = rs.getString("title");
                String owner = rs.getString("owner");
                String executor = rs.getString("executor");
                String description = rs.getString("description");
                Task.Status status = Task.Status.valueOf(rs.getString("status"));

                task = new Task(id, title, owner, executor, description, status);
                break;
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            disconnect();
        }
        return task;
    }

    // добавить задачу
    @Override
    public void addTask(Long id, String title, String owner, String executor, String description, Task.Status status) {
        if (id == null) {
            throw new TaskNoFound("нельзя добавить задачу - нет идентификатора");
        }
        if (title == null) {
            throw new TaskNoFound("нельзя добавить задачу - нет названия");
        }
        if (isTaskExist(id)) {
            throw new TaskAlreadyExist(id, title);
        }

        String query = "insert into tasks (id, title, owner, executor, description, status) " +
                "values (" + id + ", '" + title + "', '" + owner + "', '" + executor + "', '" + description + "', '" + status.name() + "');";
        try {
            connect();
            stmt.executeUpdate(query);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            disconnect();
        }
    }

    @Override
    public void editTask(Task newTask) {
        if (newTask == null) {
            throw new TaskNoFound("нельзя редактировать задачу - объект пустой");
        }
        if (newTask.getId() == null) {
            throw new TaskNoFound("нельзя редактировать задачу - нет идентификатора");
        }
        if (newTask.getTitle() == null) {
            throw new TaskNoFound("нельзя редактировать задачу - нет названия");
        }
        if (!isTaskExist(newTask.getId())) {
            throw new TaskNoFound("не найдена задача с id = " + newTask.getId());
        }

        String query = "update tasks set title = '" + newTask.getTitle() + "', owner = '" + newTask.getOwner() + "', executor = '" + newTask.getExecutor() + "', description = '" + newTask.getDescription() + "', status = '" + newTask.getStatus() + "' where id = " + newTask.getId() + ";";
        try {
            connect();
            stmt.executeUpdate(query);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            disconnect();
        }
    }

    // удалить задачу по идентификатору
    @Override
    public void delTask(Long id) {
        if (id == null) {
            throw new TaskNoFound("нельзя удалить задачу - нет идентификатора");
        }
        if (!isTaskExist(id)) {
            throw new TaskNoFound("не найдена задача с id = " + id);
        }

        String query = "delete from tasks where id =" + id + ";";
        try {
            connect();
            stmt.executeUpdate(query);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            disconnect();
        }
    }

    // распечатать список задач
    @Override
    public void printList() {
        List<Task> tasks = getTasks();
        for (Task task : tasks) {
            System.out.println(task.toString());
        }
    }

    // подключиться с БД
    private void connect() throws ClassNotFoundException, SQLException {
        Class.forName("org.sqlite.JDBC");
        connection = DriverManager.getConnection("jdbc:sqlite:E:\\SQLite\\example.db"); // открываем соединение с БД
        stmt = connection.createStatement(); // позволяет отправлять запросы через соединение
    }

    // отключиться от БД
    private void disconnect() {
        // закрываем всё в обратном порядке по степени важности (чтобы гарантированно не было проблем)
        try {
            stmt.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
        try {
            connection.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}




package com.geekbrains.training.homework.services;
import com.geekbrains.training.homework.entities.Task;
import com.geekbrains.training.homework.exceptions.TaskAlreadyExist;
import com.geekbrains.training.homework.exceptions.TaskNoFound;
import com.geekbrains.training.homework.fonts.Fonts;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.List;
import java.util.StringTokenizer;
import java.util.stream.Collectors;

public class TaskService {
    private String delimiter = ";";

/*
    private TaskRepository taskRepository;
    public TaskService() {
        taskRepository = new TaskRepository();
    }*/

    private TaskRepoDB taskRepository;

    public TaskService() {
        taskRepository = new TaskRepoDB();
    }

    public String getNameRepo() {
        return taskRepository.getNameRepo();
    }

    public void isTaskExist(Long id, String title) {
        try {
            if (taskRepository.isTaskExist(id, title)) {
                System.out.println(Fonts.Color.GREEN + "Задача найдена [id = " + id + ", title = " + title + "]" + Fonts.Color.RESET);
            } else {
                System.out.println(Fonts.Color.RED + "Задача отсутствует [id = " + id + ", title = " + title + "]!" + Fonts.Color.RESET);
            }
        } catch (TaskNoFound e) {
            System.out.println(Fonts.Color.RED + e.getMessage() + Fonts.Color.RESET);
        }
    }

    public Task findTaskById(Long id) {
        Task task = null;
        try {
            task = taskRepository.findTaskById(id);
            if (task == null) {
                System.out.println(Fonts.Color.RED + "Задача отсутствует [id = " + id + "]!" + Fonts.Color.RESET);
            } else {
                System.out.println(Fonts.Color.GREEN + "Задача найдена [id = " + id + "]!" + Fonts.Color.RESET);
            }
        } catch (TaskNoFound e) {
            System.out.println(Fonts.Color.RED + e.getMessage() + Fonts.Color.RESET);
        }
        return task;
    }

    public void addTask(Long id, String title, String owner, String executor, String description, Task.Status status) {
        try {
            taskRepository.addTask(id, title, owner, executor, description, status == null ? Task.Status.CREATED : status);
            System.out.println(Fonts.Color.GREEN + "Задача успешно добавлена [id = " + id + ", title = " + title + "]" + Fonts.Color.RESET);
        } catch (TaskAlreadyExist | TaskNoFound e) {
            System.out.println(Fonts.Color.RED + e.getMessage() + Fonts.Color.RESET);
        }
    }

    public void editTask(Task newTask) {
        try {
            taskRepository.editTask(newTask);
            System.out.println(Fonts.Color.GREEN + "Задача успешно обновлена [id = " + newTask.getId() + "]" + Fonts.Color.RESET);
        } catch (TaskNoFound e) {
            System.out.println(Fonts.Color.RED + e.getMessage() + Fonts.Color.RESET);
        }
    }

    public void delTask(Long id) throws TaskNoFound {
        try {
            taskRepository.delTask(id);
            System.out.println(Fonts.Color.GREEN + "Задача успешно удалена [id = " + id + "]" + Fonts.Color.RESET);
        } catch (TaskNoFound e) {
            System.out.println(Fonts.Color.RED + e.getMessage() + Fonts.Color.RESET);
        }
    }

    public void printList() {
        taskRepository.printList();
    }

    /////////////////////////////////////////////////////////////////////////////////
    // STREAM API
    /////////////////////////////////////////////////////////////////////////////////
    // получение списка задач по выбранному статусу
    public List<Task> streamTaskListByStatus(Task.Status status) {
        return taskRepository.getTasks().stream()
                .filter(task -> task.getStatus() == status)
                .collect(Collectors.toList());
    }

    // проверка наличия задачи с указанным ID
    public boolean streamPrintTaskListByStatus(Long id) {
        if (id == null) {
            return false;
        }
        return taskRepository.getTasks().stream().anyMatch(task -> task.getId().equals(id));
    }

    // получение списка задач в отсортированном по статусу виде
    public List<Task> streamPrintTaskListSortByStatus() {
        return taskRepository.getTasks().stream()
                .sorted((o1, o2) -> o1.getStatus().compareTo(o2.getStatus()))
                .collect(Collectors.toList());
    }

    // подсчёт количества задач по определенному статусу
    public long streamCountTasksByStatus(Task.Status status) {
        return taskRepository.getTasks().stream().filter((p) -> (p.getStatus() == status)).count();
    }


    /////////////////////////////////////////////////////////////////////////////////
    //  I / O
    /////////////////////////////////////////////////////////////////////////////////
    // записать задачи из репозитория в файл
    public int saveRepoToFile() {
        int countRows = 0;
        try {
            FileWriter writer = new FileWriter("Repository.csv");
            for (Task task : taskRepository.getTasks()) {
                writer.write(task.getId() + delimiter + task.getTitle() + delimiter + task.getOwner() + delimiter + task.getExecutor() + delimiter + task.getDescription() + delimiter + task.getStatus());
                writer.write(System.getProperty("line.separator"));
                countRows++;
            }
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return countRows;
    }

    // прочитать задачи из файла и загрузить их в репозиторий
    public int readRepoFromFile() {
        int countRows = 0;
        try {
            FileReader fr = new FileReader("Repository.csv");
            BufferedReader reader = new BufferedReader(fr);
            String line = null;
            while ((line = reader.readLine()) != null) {
                // читаем всю строку с разделителями
                StringTokenizer stk = new StringTokenizer(line, delimiter);
                // парсим
                Long id = Long.valueOf(stk.nextToken());
                String title = stk.nextToken();
                String owner = stk.nextToken();
                String executor = stk.nextToken();
                String description = stk.nextToken();
                Task.Status status = Task.Status.valueOf(stk.nextToken());

                addTask(id, title, owner, executor, description, status);
                countRows++;
            }
            reader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return countRows;
    }
}




package com.geekbrains.training.homework;
import com.geekbrains.training.homework.entities.Task;
import com.geekbrains.training.homework.fonts.Fonts;
import com.geekbrains.training.homework.services.TaskRepoDB;
import com.geekbrains.training.homework.services.TaskService;
import java.sql.*;
import java.util.List;

public class MainApp {
    private static Connection connection;
    private static Statement stmt;
    private static PreparedStatement psInsert;

    public static void main(String[] args) {
        // создание репозитория
        System.out.println("+-----------------------------+");
        System.out.println("| Создан репозиторий          |");
        System.out.println("+-----------------------------+");
        TaskService taskService = new TaskService();
        System.out.println(taskService.getNameRepo());
        taskService.printList();
        System.out.println();

        System.out.println("+-----------------------------+");
        System.out.println("| Проверка поиска isTaskExist |");
        System.out.println("+-----------------------------+");
        taskService.isTaskExist(0L, "Task0");
        taskService.isTaskExist(1L, "Task1");
        taskService.isTaskExist(null, "Task2");
        taskService.isTaskExist(2L, null);
        System.out.println();

        System.out.println("+-----------------------------+");
        System.out.println("| Проверка поиска findTaskById |");
        System.out.println("+-----------------------------+");
        taskService.findTaskById(null);
        taskService.findTaskById(888L);
        taskService.findTaskById(0L);
        System.out.println();

        System.out.println("+---------------------+");
        System.out.println("| Проверка добавления |");
        System.out.println("+---------------------+");
        taskService.addTask(1L, "Task1", "owner1", "executor1", "Create task 1", null);
        System.out.println("Повторное добавление такой же записи:");
        taskService.addTask(1L, "Task1", "owner1", "executor1", "Create task 1", null);
        System.out.println("Добавление id = NULL:");
        taskService.addTask(null, "Task1", "owner1", "executor1", "Create task 1", null);
        System.out.println("Добавление title = NULL:");
        taskService.addTask(10L, null, "owner10", "executor10", "Create task 10", null);
        taskService.printList();
        System.out.println();

        System.out.println("+---------------------+");
        System.out.println("| Проверка обновления |");
        System.out.println("+---------------------+");
        Task newTask = null;
        taskService.editTask(newTask);
        newTask = taskService.findTaskById(1L);
        newTask.setTitle("NewTitle1");
        newTask.setOwner("NewOwner1");
        newTask.setExecutor("NewExecutor1");
        newTask.setDescription("NewDescription1");
        newTask.setStatus(Task.Status.REJECTED);
        taskService.editTask(newTask);
        taskService.editTask(new Task(888L, "Task_1", "Owner_1", "Executor_1", "Create task 1", Task.Status.CLOSED));
        taskService.printList();
        System.out.println();

        System.out.println("+-------------------+");
        System.out.println("| Проверка удаления |");
        System.out.println("+-------------------+");
        taskService.delTask(null);
        taskService.delTask(1L);
        taskService.delTask(1L);
        taskService.printList();
        System.out.println();

        System.out.println("+-------------------------------------+");
        System.out.println("| Проверка добавления с переполнением |");
        System.out.println("+-------------------------------------+");
        for (int i = 0; i < 12; i++) {
            taskService.addTask((long) i, "Task" + i, "NewOwner" + i, "NewExecutor" + i, "Create new task " + i, null);
        }
        taskService.printList();
        System.out.println();

        System.out.println("+-------------------------------------+");
        System.out.println("|       S T R E A M     A P I         |");
        System.out.println("+-------------------------------------+");
        System.out.println(Fonts.Color.BLUE + "ИСХОДНЫЙ СПИСОК ЗАДАЧ:" + Fonts.Color.RESET);
        taskService.printList();

        Task.Status status = Task.Status.CREATED;
        System.out.println(Fonts.Color.BLUE + "ЗАДАЧИ СО СТАТУСОМ: " + status.getRusTitle() + Fonts.Color.RESET);
        taskService.streamTaskListByStatus(status).forEach(System.out::println);
        status = Task.Status.IN_WORK;
        System.out.println(Fonts.Color.BLUE + "ЗАДАЧИ СО СТАТУСОМ: " + status.getRusTitle() + Fonts.Color.RESET);
        taskService.streamTaskListByStatus(status).forEach(System.out::println);
        status = Task.Status.CLOSED;
        System.out.println(Fonts.Color.BLUE + "ЗАДАЧИ СО СТАТУСОМ: " + status.getRusTitle() + Fonts.Color.RESET);
        taskService.streamTaskListByStatus(status).forEach(System.out::println);
        status = Task.Status.REJECTED;
        System.out.println(Fonts.Color.BLUE + "ЗАДАЧИ СО СТАТУСОМ: " + status.getRusTitle() + Fonts.Color.RESET);
        taskService.streamTaskListByStatus(status).forEach(System.out::println);
        status = Task.Status.SUSPENDED;
        System.out.println(Fonts.Color.BLUE + "ЗАДАЧИ СО СТАТУСОМ: " + status.getRusTitle() + Fonts.Color.RESET);
        taskService.streamTaskListByStatus(status).forEach(System.out::println);
        status = null;
        System.out.println(Fonts.Color.BLUE + "ЗАДАЧИ С ПУСТЫМ СТАТУСОМ:" + Fonts.Color.RESET);
        taskService.streamTaskListByStatus(status).forEach(System.out::println);
        System.out.println();

        System.out.println(Fonts.Color.BLUE + "ПРОВЕРКА ПОИСКА ЗАДАЧ ПО ID:" + Fonts.Color.RESET);
        Long id = 1L;
        if (taskService.streamPrintTaskListByStatus(id)) {
            System.out.println(Fonts.Color.GREEN + "Есть задача с id = " + id + Fonts.Color.RESET);
        } else {
            System.out.println(Fonts.Color.RED + "Нет задач с id = " + id + Fonts.Color.RESET);
        }
        id = 2L;
        if (taskService.streamPrintTaskListByStatus(id)) {
            System.out.println(Fonts.Color.GREEN + "Есть задача с id = " + id + Fonts.Color.RESET);
        } else {
            System.out.println(Fonts.Color.RED + "Нет задач с id = " + id + Fonts.Color.RESET);
        }
        id = 64L;
        if (taskService.streamPrintTaskListByStatus(id)) {
            System.out.println(Fonts.Color.GREEN + "Есть задача с id = " + id + Fonts.Color.RESET);
        } else {
            System.out.println(Fonts.Color.RED + "Нет задач с id = " + id + Fonts.Color.RESET);
        }
        System.out.println();

        System.out.println(Fonts.Color.BLUE + "СПИСОК ЗАДАЧ, ОТСОРТИРОВАННЫЙ ПО СТАТУСУ:" + Fonts.Color.RESET);
        List<Task> tasksByStatus = taskService.streamPrintTaskListSortByStatus();
        if (tasksByStatus.size() == 0) {
            System.out.println(Fonts.Color.RED + "Список получился пустым!" + Fonts.Color.RESET);
        } else {
            tasksByStatus.forEach(System.out::println);
        }
        System.out.println();

        System.out.println(Fonts.Color.BLUE + "КОЛИЧЕСТВО ЗАДАЧ ПО ЗАДАННОМУ СТАТУСУ:" + Fonts.Color.RESET);
        status = Task.Status.CREATED;
        System.out.println(status.getRusTitle() + " = " + taskService.streamCountTasksByStatus(status) + " задач");
        status = Task.Status.IN_WORK;
        System.out.println(status.getRusTitle() + " = " + taskService.streamCountTasksByStatus(status) + " задач");
        status = Task.Status.CLOSED;
        System.out.println(status.getRusTitle() + " = " + taskService.streamCountTasksByStatus(status) + " задач");
        status = Task.Status.REJECTED;
        System.out.println(status.getRusTitle() + " = " + taskService.streamCountTasksByStatus(status) + " задач");
        status = Task.Status.SUSPENDED;
        System.out.println(status.getRusTitle() + " = " + taskService.streamCountTasksByStatus(status) + " задач");
        System.out.println();


        System.out.println("+-------------------------------------+");
        System.out.println("|                 I / O               |");
        System.out.println("+-------------------------------------+");
        System.out.println(Fonts.Color.BLUE + "Список задач:" + Fonts.Color.RESET);
        taskService.printList();

        System.out.println("Записано в файл " + taskService.saveRepoToFile() + " строк.");
        System.out.println();

        System.out.println("Загружено из файла " + taskService.readRepoFromFile() + " строк."); // ошибки, т.к. такие строки уже есть
        System.out.println();

        // почистим репозиторий
        for (int i = 0; i < 30; i += 2) {
            taskService.delTask((long) i);
        }
        System.out.println();

        System.out.println(Fonts.Color.BLUE + "Список задач:" + Fonts.Color.RESET);
        taskService.printList();
        System.out.println();

        System.out.println("Считано из файла " + taskService.readRepoFromFile() + " строк.");
    }
}